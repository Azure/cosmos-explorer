{"version":3,"file":"Databases.js","sourceRoot":"","sources":["../../../../src/client/Database/Databases.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { ClientContext } from \"../../ClientContext\";\nimport { Constants, isResourceValid, ResourceType, StatusCodes } from \"../../common\";\nimport { CosmosClient } from \"../../CosmosClient\";\nimport { FetchFunctionCallback, mergeHeaders, SqlQuerySpec } from \"../../queryExecutionContext\";\nimport { QueryIterator } from \"../../queryIterator\";\nimport { FeedOptions, RequestOptions } from \"../../request\";\nimport { Resource } from \"../Resource\";\nimport { Database } from \"./Database\";\nimport { DatabaseDefinition } from \"./DatabaseDefinition\";\nimport { DatabaseRequest } from \"./DatabaseRequest\";\nimport { DatabaseResponse } from \"./DatabaseResponse\";\nimport { validateOffer } from \"../../utils/offers\";\nimport { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal\";\nimport { getEmptyCosmosDiagnostics, withDiagnostics } from \"../../utils/diagnostics\";\n\n/**\n * Operations for creating new databases, and reading/querying all databases\n *\n * @see {@link Database} for reading or deleting an existing database; use `client.database(id)`.\n *\n * Note: all these operations make calls against a fixed budget.\n * You should design your system such that these calls scale sublinearly with your application.\n * For instance, do not call `databases.readAll()` before every single `item.read()` call, to ensure the database exists;\n * do this once on application start up.\n */\nexport class Databases {\n  /**\n   * @hidden\n   * @param client - The parent {@link CosmosClient} for the Database.\n   */\n  constructor(\n    public readonly client: CosmosClient,\n    private readonly clientContext: ClientContext,\n  ) {}\n\n  /**\n   * Queries all databases.\n   * @param query - Query configuration for the operation. See {@link SqlQuerySpec} for more info on how to configure a query.\n   * @param options - Use to set options like response page size, continuation tokens, etc.\n   * @returns {@link QueryIterator} Allows you to return all databases in an array or iterate over them one at a time.\n   * @example Read all databases to array.\n   * ```typescript\n   * const querySpec: SqlQuerySpec = {\n   *   query: \"SELECT * FROM root r WHERE r.id = @db\",\n   *   parameters: [\n   *     {name: \"@db\", value: \"Todo\"}\n   *   ]\n   * };\n   * const {body: databaseList} = await client.databases.query(querySpec).fetchAll();\n   * ```\n   */\n  public query(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;\n  /**\n   * Queries all databases.\n   * @param query - Query configuration for the operation. See {@link SqlQuerySpec} for more info on how to configure a query.\n   * @param options - Use to set options like response page size, continuation tokens, etc.\n   * @returns {@link QueryIterator} Allows you to return all databases in an array or iterate over them one at a time.\n   * @example Read all databases to array.\n   * ```typescript\n   * const querySpec: SqlQuerySpec = {\n   *   query: \"SELECT * FROM root r WHERE r.id = @db\",\n   *   parameters: [\n   *     {name: \"@db\", value: \"Todo\"}\n   *   ]\n   * };\n   * const {body: databaseList} = await client.databases.query(querySpec).fetchAll();\n   * ```\n   */\n  public query<T>(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;\n  public query<T>(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<T> {\n    const cb: FetchFunctionCallback = (diagNode: DiagnosticNodeInternal, innerOptions) => {\n      return this.clientContext.queryFeed({\n        path: \"/dbs\",\n        resourceType: ResourceType.database,\n        resourceId: \"\",\n        resultFn: (result) => result.Databases,\n        query,\n        options: innerOptions,\n        diagnosticNode: diagNode,\n      });\n    };\n    return new QueryIterator(this.clientContext, query, options, cb);\n  }\n\n  /**\n   * Send a request for creating a database.\n   *\n   * A database manages users, permissions and a set of containers.\n   * Each Azure Cosmos DB Database Account is able to support multiple independent named databases,\n   * with the database being the logical container for data.\n   *\n   * Each Database consists of one or more containers, each of which in turn contain one or more\n   * documents. Since databases are an administrative resource, the Service Master Key will be\n   * required in order to access and successfully complete any action using the User APIs.\n   *\n   * @param body - The {@link DatabaseDefinition} that represents the {@link Database} to be created.\n   * @param options - Use to set options like response page size, continuation tokens, etc.\n   */\n  public async create(\n    body: DatabaseRequest,\n    options: RequestOptions = {},\n  ): Promise<DatabaseResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      return this.createInternal(diagnosticNode, body, options);\n    }, this.clientContext);\n  }\n\n  /**\n   * @hidden\n   */\n  public async createInternal(\n    diagnosticNode: DiagnosticNodeInternal,\n    body: DatabaseRequest,\n    options: RequestOptions = {},\n  ): Promise<DatabaseResponse> {\n    const err = {};\n    if (!isResourceValid(body, err)) {\n      throw err;\n    }\n\n    validateOffer(body);\n\n    if (body.maxThroughput) {\n      const autoscaleParams: {\n        maxThroughput: number;\n        autoUpgradePolicy?: {\n          throughputPolicy: {\n            incrementPercent: number;\n          };\n        };\n      } = {\n        maxThroughput: body.maxThroughput,\n      };\n      if (body.autoUpgradePolicy) {\n        autoscaleParams.autoUpgradePolicy = body.autoUpgradePolicy;\n      }\n      const autoscaleHeaders = JSON.stringify(autoscaleParams);\n      options.initialHeaders = Object.assign({}, options.initialHeaders, {\n        [Constants.HttpHeaders.AutoscaleSettings]: autoscaleHeaders,\n      });\n      delete body.maxThroughput;\n      delete body.autoUpgradePolicy;\n    }\n\n    if (body.throughput) {\n      options.initialHeaders = Object.assign({}, options.initialHeaders, {\n        [Constants.HttpHeaders.OfferThroughput]: body.throughput,\n      });\n      delete body.throughput;\n    }\n\n    const path = \"/dbs\"; // TODO: constant\n    const response = await this.clientContext.create<DatabaseRequest>({\n      body,\n      path,\n      resourceType: ResourceType.database,\n      resourceId: undefined,\n      diagnosticNode,\n      options,\n    });\n    const ref = new Database(this.client, body.id, this.clientContext);\n    return new DatabaseResponse(\n      response.result,\n      response.headers,\n      response.code,\n      ref,\n      getEmptyCosmosDiagnostics(),\n    );\n  }\n\n  /**\n   * Check if a database exists, and if it doesn't, create it.\n   * This will make a read operation based on the id in the `body`, then if it is not found, a create operation.\n   *\n   * A database manages users, permissions and a set of containers.\n   * Each Azure Cosmos DB Database Account is able to support multiple independent named databases,\n   * with the database being the logical container for data.\n   *\n   * Each Database consists of one or more containers, each of which in turn contain one or more\n   * documents. Since databases are an an administrative resource, the Service Master Key will be\n   * required in order to access and successfully complete any action using the User APIs.\n   *\n   * @param body - The {@link DatabaseDefinition} that represents the {@link Database} to be created.\n   * @param options - Additional options for the request\n   */\n  public async createIfNotExists(\n    body: DatabaseRequest,\n    options?: RequestOptions,\n  ): Promise<DatabaseResponse> {\n    if (!body || body.id === null || body.id === undefined) {\n      throw new Error(\"body parameter must be an object with an id property\");\n    }\n    /*\n      1. Attempt to read the Database (based on an assumption that most databases will already exist, so its faster)\n      2. If it fails with NotFound error, attempt to create the db. Else, return the read results.\n    */\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      try {\n        const readResponse = await this.client\n          .database(body.id)\n          .readInternal(diagnosticNode, options);\n        return readResponse;\n      } catch (err: any) {\n        if (err.code === StatusCodes.NotFound) {\n          const createResponse = await this.createInternal(diagnosticNode, body, options);\n          // Must merge the headers to capture RU costskaty\n          mergeHeaders(createResponse.headers, err.headers);\n          return createResponse;\n        } else {\n          throw err;\n        }\n      }\n    }, this.clientContext);\n  }\n\n  // TODO: DatabaseResponse for QueryIterator?\n  /**\n   * Reads all databases.\n   * @param options - Use to set options like response page size, continuation tokens, etc.\n   * @returns {@link QueryIterator} Allows you to return all databases in an array or iterate over them one at a time.\n   * @example Read all databases to array.\n   * ```typescript\n   * const {body: databaseList} = await client.databases.readAll().fetchAll();\n   * ```\n   */\n  public readAll(options?: FeedOptions): QueryIterator<DatabaseDefinition & Resource> {\n    return this.query<DatabaseDefinition & Resource>(undefined, options);\n  }\n}\n"]}