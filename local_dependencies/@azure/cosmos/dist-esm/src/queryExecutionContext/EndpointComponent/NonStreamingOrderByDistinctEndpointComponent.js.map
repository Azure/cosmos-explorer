{"version":3,"file":"NonStreamingOrderByDistinctEndpointComponent.js","sourceRoot":"","sources":["../../../../src/queryExecutionContext/EndpointComponent/NonStreamingOrderByDistinctEndpointComponent.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { QueryInfo, QueryOperationOptions, Response } from \"../../request\";\nimport { ExecutionContext } from \"../ExecutionContext\";\nimport { getInitialHeader } from \"../headerUtils\";\nimport { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal\";\nimport { hashObject } from \"../../utils/hashObject\";\nimport { RUConsumedManager } from \"../../common\";\nimport { NonStreamingOrderByResult } from \"../nonStreamingOrderByResult\";\nimport { NonStreamingOrderByResponse } from \"../nonStreamingOrderByResponse\";\nimport { NonStreamingOrderByPriorityQueue } from \"../../utils/nonStreamingOrderByPriorityQueue\";\nimport { NonStreamingOrderByMap } from \"../../utils/nonStreamingOrderByMap\";\nimport { OrderByComparator } from \"../orderByComparator\";\n\n/** @hidden */\nexport class NonStreamingOrderByDistinctEndpointComponent implements ExecutionContext {\n  private aggregateMap: NonStreamingOrderByMap<NonStreamingOrderByResult>; // map to store distinct values before storing in pq.\n  private nonStreamingOrderByPQ: NonStreamingOrderByPriorityQueue<NonStreamingOrderByResult>; // pq to compute final orderBy results\n  private finalResultArray: NonStreamingOrderByResult[]; // result array to store final sorted and orderBy results.\n  private sortOrders: string[];\n  private isCompleted: boolean = false;\n\n  constructor(\n    private executionContext: ExecutionContext,\n    private queryInfo: QueryInfo,\n    private priorityQueueBufferSize: number,\n  ) {\n    this.sortOrders = this.queryInfo.orderBy;\n    const comparator = new OrderByComparator(this.sortOrders);\n    this.aggregateMap = new NonStreamingOrderByMap<NonStreamingOrderByResult>(\n      (a: NonStreamingOrderByResult, b: NonStreamingOrderByResult) => {\n        return comparator.compareItems(a, b);\n      },\n    );\n    this.nonStreamingOrderByPQ = new NonStreamingOrderByPriorityQueue<NonStreamingOrderByResult>(\n      (a: NonStreamingOrderByResult, b: NonStreamingOrderByResult) => {\n        return comparator.compareItems(b, a);\n      },\n      this.priorityQueueBufferSize,\n    );\n  }\n\n  public async nextItem(\n    diagnosticNode: DiagnosticNodeInternal,\n    operationOptions?: QueryOperationOptions,\n    ruConsumedManager?: RUConsumedManager,\n  ): Promise<Response<any>> {\n    // if size is 0, just return undefined. Valid if query is TOP 0 or LIMIT 0\n    if (this.priorityQueueBufferSize === 0) {\n      return {\n        result: undefined,\n        headers: getInitialHeader(),\n      };\n    }\n\n    let resHeaders = getInitialHeader();\n    if (!this.isCompleted && this.executionContext.hasMoreResults()) {\n      // Grab the next result\n      const { result, headers } = (await this.executionContext.nextItem(\n        diagnosticNode,\n        operationOptions,\n        ruConsumedManager,\n      )) as NonStreamingOrderByResponse;\n      resHeaders = headers;\n      if (result) {\n        // make hash of result object and update the map if required.\n        const key = await hashObject(result?.payload);\n        this.aggregateMap.set(key, result);\n      }\n\n      if (!this.executionContext.hasMoreResults()) {\n        this.isCompleted = true;\n        await this.buildFinalResultArray();\n      }\n    }\n    if (this.isCompleted) {\n      // start returning the results if final result is computed.\n      if (this.finalResultArray.length > 0) {\n        return {\n          result: this.finalResultArray.shift(),\n          headers: resHeaders,\n        };\n      } else {\n        return {\n          result: undefined,\n          headers: getInitialHeader(),\n        };\n      }\n    } else {\n      // keep returning empty till final results are getting computed.\n      return {\n        result: {},\n        headers: resHeaders,\n      };\n    }\n  }\n  /**\n   * Build final sorted result array from which responses will be served.\n   */\n  private async buildFinalResultArray(): Promise<void> {\n    const allValues = this.aggregateMap.getAllValues();\n    for (const value of allValues) {\n      this.nonStreamingOrderByPQ.enqueue(value);\n    }\n    const offSet = this.queryInfo.offset ? this.queryInfo.offset : 0;\n    const queueSize = this.nonStreamingOrderByPQ.size();\n    const finalArraySize = queueSize - offSet;\n\n    if (finalArraySize <= 0) {\n      this.finalResultArray = [];\n    } else {\n      this.finalResultArray = new Array(finalArraySize);\n\n      for (let count = finalArraySize - 1; count >= 0; count--) {\n        this.finalResultArray[count] = this.nonStreamingOrderByPQ.dequeue()?.payload;\n      }\n    }\n  }\n\n  public hasMoreResults(): boolean {\n    if (this.priorityQueueBufferSize === 0) return false;\n    return this.executionContext.hasMoreResults() || this.finalResultArray.length > 0;\n  }\n}\n"]}