{"version":3,"file":"NonStreamingOrderByEndpointComponent.js","sourceRoot":"","sources":["../../../../src/queryExecutionContext/EndpointComponent/NonStreamingOrderByEndpointComponent.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { RUConsumedManager } from \"../../common/RUConsumedManager\";\nimport { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal\";\nimport { QueryOperationOptions, Response } from \"../../request\";\nimport { ExecutionContext } from \"../ExecutionContext\";\nimport { OrderByComparator } from \"../orderByComparator\";\nimport { NonStreamingOrderByResult } from \"../nonStreamingOrderByResult\";\nimport { NonStreamingOrderByPriorityQueue } from \"../../utils/nonStreamingOrderByPriorityQueue\";\nimport { getInitialHeader } from \"../headerUtils\";\nimport { RUCapPerOperationExceededErrorCode } from \"../../request/RUCapPerOperationExceededError\";\nexport class NonStreamingOrderByEndpointComponent implements ExecutionContext {\n  private nonStreamingOrderByPQ: NonStreamingOrderByPriorityQueue<NonStreamingOrderByResult>;\n  private isCompleted: boolean = false;\n  /**\n   * Represents an endpoint in handling an non-streaming order by query. For each processed orderby\n   * result it returns 'payload' item of the result\n   *\n   * @param executionContext - Underlying Execution Context\n   * @hidden\n   */\n  constructor(\n    private executionContext: ExecutionContext,\n    private sortOrders: any[],\n    private priorityQueueBufferSize: number = 2000,\n    private offset: number = 0,\n  ) {\n    const comparator = new OrderByComparator(this.sortOrders);\n    this.nonStreamingOrderByPQ = new NonStreamingOrderByPriorityQueue<NonStreamingOrderByResult>(\n      (a: NonStreamingOrderByResult, b: NonStreamingOrderByResult) => {\n        return comparator.compareItems(b, a);\n      },\n      this.priorityQueueBufferSize,\n    );\n  }\n\n  public async nextItem(\n    diagnosticNode: DiagnosticNodeInternal,\n    operationOptions?: QueryOperationOptions,\n    ruConsumedManager?: RUConsumedManager,\n  ): Promise<Response<any>> {\n    if (\n      this.priorityQueueBufferSize <= 0 ||\n      (this.isCompleted && this.nonStreamingOrderByPQ.isEmpty())\n    ) {\n      return {\n        result: undefined,\n        headers: getInitialHeader(),\n      };\n    }\n\n    if (this.isCompleted && !this.nonStreamingOrderByPQ.isEmpty()) {\n      const item = this.nonStreamingOrderByPQ.dequeue()?.payload;\n      return {\n        result: item,\n        headers: getInitialHeader(),\n      };\n    }\n    try {\n      if (this.executionContext.hasMoreResults()) {\n        const { result: item, headers } = await this.executionContext.nextItem(\n          diagnosticNode,\n          operationOptions,\n          ruConsumedManager,\n        );\n        if (item !== undefined) {\n          this.nonStreamingOrderByPQ.enqueue(item);\n        }\n        return {\n          result: {},\n          headers,\n        };\n      } else {\n        this.isCompleted = true;\n        // Reverse the priority queue to get the results in the correct order\n        this.nonStreamingOrderByPQ = this.nonStreamingOrderByPQ.reverse();\n        // For offset limit case we set the size of priority queue to offset + limit\n        // and we drain offset number of items from the priority queue\n        while (this.offset < this.priorityQueueBufferSize && this.offset > 0) {\n          this.nonStreamingOrderByPQ.dequeue();\n          this.offset--;\n        }\n\n        if (this.nonStreamingOrderByPQ.size() !== 0) {\n          const item = this.nonStreamingOrderByPQ.dequeue()?.payload;\n          return {\n            result: item,\n            headers: getInitialHeader(),\n          };\n        } else {\n          return {\n            result: undefined,\n            headers: getInitialHeader(),\n          };\n        }\n      }\n    } catch (err) {\n      if (err.code === RUCapPerOperationExceededErrorCode) {\n        err.fetchedResults = undefined;\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Determine if there are still remaining resources to processs.\n   * @returns true if there is other elements to process in the NonStreamingOrderByEndpointComponent.\n   */\n  public hasMoreResults(): boolean {\n    return (\n      this.priorityQueueBufferSize > 0 &&\n      (this.executionContext.hasMoreResults() || this.nonStreamingOrderByPQ.size() !== 0)\n    );\n  }\n}\n"]}