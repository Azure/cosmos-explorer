{"version":3,"file":"OrderByEndpointComponent.js","sourceRoot":"","sources":["../../../../src/queryExecutionContext/EndpointComponent/OrderByEndpointComponent.ts"],"names":[],"mappings":"AAIA,OAAO,EAAE,kCAAkC,EAAE,MAAM,8CAA8C,CAAC;AAIlG,cAAc;AACd,MAAM,OAAO,wBAAwB;IACnC;;;;;;OAMG;IACH,YAAoB,gBAAkC;QAAlC,qBAAgB,GAAhB,gBAAgB,CAAkB;IAAG,CAAC;IAC1D;;OAEG;IACI,KAAK,CAAC,QAAQ,CACnB,cAAsC,EACtC,gBAAwC,EACxC,iBAAqC;QAErC,IAAI;YACF,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CACpE,cAAc,EACd,gBAAgB,EAChB,iBAAiB,CAClB,CAAC;YACF,OAAO;gBACL,MAAM,EAAE,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,SAAS;gBACrD,OAAO;aACR,CAAC;SACH;QAAC,OAAO,GAAG,EAAE;YACZ,IAAI,GAAG,CAAC,IAAI,KAAK,kCAAkC,EAAE;gBACnD,GAAG,CAAC,cAAc,GAAG,SAAS,CAAC;aAChC;YACD,MAAM,GAAG,CAAC;SACX;IACH,CAAC;IAED;;;OAGG;IACI,cAAc;QACnB,OAAO,IAAI,CAAC,gBAAgB,CAAC,cAAc,EAAE,CAAC;IAChD,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal\";\nimport { QueryOperationOptions, Response } from \"../../request\";\nimport { RUCapPerOperationExceededErrorCode } from \"../../request/RUCapPerOperationExceededError\";\nimport { ExecutionContext } from \"../ExecutionContext\";\nimport { RUConsumedManager } from \"../../common\";\n\n/** @hidden */\nexport class OrderByEndpointComponent implements ExecutionContext {\n  /**\n   * Represents an endpoint in handling an order by query. For each processed orderby\n   * result it returns 'payload' item of the result\n   *\n   * @param executionContext - Underlying Execution Context\n   * @hidden\n   */\n  constructor(private executionContext: ExecutionContext) {}\n  /**\n   * Execute a provided function on the next element in the OrderByEndpointComponent.\n   */\n  public async nextItem(\n    diagnosticNode: DiagnosticNodeInternal,\n    operationOptions?: QueryOperationOptions,\n    ruConsumedManager?: RUConsumedManager,\n  ): Promise<Response<any>> {\n    try {\n      const { result: item, headers } = await this.executionContext.nextItem(\n        diagnosticNode,\n        operationOptions,\n        ruConsumedManager,\n      );\n      return {\n        result: item !== undefined ? item.payload : undefined,\n        headers,\n      };\n    } catch (err) {\n      if (err.code === RUCapPerOperationExceededErrorCode) {\n        err.fetchedResults = undefined;\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Determine if there are still remaining resources to processs.\n   * @returns true if there is other elements to process in the OrderByEndpointComponent.\n   */\n  public hasMoreResults(): boolean {\n    return this.executionContext.hasMoreResults();\n  }\n}\n"]}