{"version":3,"file":"defaultQueryExecutionContext.js","sourceRoot":"","sources":["../../../src/queryExecutionContext/defaultQueryExecutionContext.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AzureLogger, createClientLogger } from \"@azure/logger\";\nimport { Constants, RUConsumedManager } from \"../common\";\nimport { ClientSideMetrics, QueryMetrics } from \"../queryMetrics\";\nimport { FeedOptions, QueryOperationOptions, Response } from \"../request\";\nimport { getInitialHeader, getRequestChargeIfAny } from \"./headerUtils\";\nimport { ExecutionContext } from \"./index\";\nimport { DiagnosticNodeInternal, DiagnosticNodeType } from \"../diagnostics/DiagnosticNodeInternal\";\nimport { addDignosticChild } from \"../utils/diagnostics\";\nimport { CosmosDbDiagnosticLevel } from \"../diagnostics/CosmosDbDiagnosticLevel\";\nimport { RUCapPerOperationExceededError } from \"../request/RUCapPerOperationExceededError\";\n\nconst logger: AzureLogger = createClientLogger(\"ClientContext\");\n/** @hidden */\nexport type FetchFunctionCallback = (\n  diagnosticNode: DiagnosticNodeInternal,\n  options: FeedOptions,\n) => Promise<Response<any>>;\n\n/** @hidden */\nenum STATES {\n  start = \"start\",\n  inProgress = \"inProgress\",\n  ended = \"ended\",\n}\n\n/** @hidden */\nexport class DefaultQueryExecutionContext implements ExecutionContext {\n  private static readonly STATES = STATES;\n  private resources: any[]; // TODO: any resources\n  private currentIndex: number;\n  private currentPartitionIndex: number;\n  private fetchFunctions: FetchFunctionCallback[];\n  private options: FeedOptions; // TODO: any options\n  public continuationToken: string; // TODO: any continuation\n  public get continuation(): string {\n    return this.continuationToken;\n  }\n  private state: STATES;\n  private nextFetchFunction: Promise<Response<any>>;\n  /**\n   * Provides the basic Query Execution Context.\n   * This wraps the internal logic query execution using provided fetch functions\n   *\n   * @param clientContext  - Is used to read the partitionKeyRanges for split proofing\n   * @param query          - A SQL query.\n   * @param options        - Represents the feed options.\n   * @param fetchFunctions - A function to retrieve each page of data.\n   *                          An array of functions may be used to query more than one partition.\n   * @hidden\n   */\n  constructor(\n    options: FeedOptions,\n    fetchFunctions: FetchFunctionCallback | FetchFunctionCallback[],\n  ) {\n    this.resources = [];\n    this.currentIndex = 0;\n    this.currentPartitionIndex = 0;\n    this.fetchFunctions = Array.isArray(fetchFunctions) ? fetchFunctions : [fetchFunctions];\n    this.options = options || {};\n    this.continuationToken = this.options.continuationToken || this.options.continuation || null;\n    this.state = DefaultQueryExecutionContext.STATES.start;\n  }\n\n  /**\n   * Execute a provided callback on the next element in the execution context.\n   */\n  public async nextItem(\n    diagnosticNode: DiagnosticNodeInternal,\n    operationOptions?: QueryOperationOptions,\n    ruConsumedManager?: RUConsumedManager,\n  ): Promise<Response<any>> {\n    ++this.currentIndex;\n    const response = await this.current(diagnosticNode, operationOptions, ruConsumedManager);\n    return response;\n  }\n\n  /**\n   * Retrieve the current element on the execution context.\n   */\n  public async current(\n    diagnosticNode: DiagnosticNodeInternal,\n    operationOptions?: QueryOperationOptions,\n    ruConsumedManager?: RUConsumedManager,\n  ): Promise<Response<any>> {\n    if (this.currentIndex < this.resources.length) {\n      return {\n        result: this.resources[this.currentIndex],\n        headers: getInitialHeader(),\n      };\n    }\n    if (this._canFetchMore()) {\n      const { result: resources, headers } = await this.fetchMore(\n        diagnosticNode,\n        operationOptions,\n        ruConsumedManager,\n      );\n      this.resources = resources;\n      if (this.resources.length === 0) {\n        if (!this.continuationToken && this.currentPartitionIndex >= this.fetchFunctions.length) {\n          this.state = DefaultQueryExecutionContext.STATES.ended;\n          return { result: undefined, headers };\n        } else {\n          return this.current(diagnosticNode, operationOptions, ruConsumedManager);\n        }\n      }\n      return { result: this.resources[this.currentIndex], headers };\n    } else {\n      this.state = DefaultQueryExecutionContext.STATES.ended;\n      return {\n        result: undefined,\n        headers: getInitialHeader(),\n      };\n    }\n  }\n\n  /**\n   * Determine if there are still remaining resources to processs based on\n   * the value of the continuation token or the elements remaining on the current batch in the execution context.\n   *\n   * @returns true if there is other elements to process in the DefaultQueryExecutionContext.\n   */\n  public hasMoreResults(): boolean {\n    return (\n      this.state === DefaultQueryExecutionContext.STATES.start ||\n      this.continuationToken !== undefined ||\n      this.currentIndex < this.resources.length - 1 ||\n      this.currentPartitionIndex < this.fetchFunctions.length\n    );\n  }\n\n  /**\n   * Fetches the next batch of the feed and pass them as an array to a callback\n   */\n  public async fetchMore(\n    diagnosticNode: DiagnosticNodeInternal,\n    operationOptions?: QueryOperationOptions,\n    ruConsumedManager?: RUConsumedManager,\n  ): Promise<Response<any>> {\n    return addDignosticChild(\n      async (childDiagnosticNode: DiagnosticNodeInternal) => {\n        if (this.currentPartitionIndex >= this.fetchFunctions.length) {\n          return {\n            headers: getInitialHeader(),\n            result: undefined,\n          };\n        }\n\n        // Keep to the original continuation and to restore the value after fetchFunction call\n        const originalContinuation = this.options.continuationToken || this.options.continuation;\n        this.options.continuationToken = this.continuationToken;\n\n        // Return undefined if there is no more results\n        if (this.currentPartitionIndex >= this.fetchFunctions.length) {\n          return {\n            headers: getInitialHeader(),\n            result: undefined,\n          };\n        }\n\n        let resources;\n        let responseHeaders;\n        try {\n          let p: Promise<Response<any>>;\n          if (this.nextFetchFunction !== undefined) {\n            logger.verbose(\"using prefetch\");\n            p = this.nextFetchFunction;\n            this.nextFetchFunction = undefined;\n          } else {\n            logger.verbose(\"using fresh fetch\");\n            p = this.fetchFunctions[this.currentPartitionIndex](childDiagnosticNode, this.options);\n          }\n          const response = await p;\n          resources = response.result;\n          childDiagnosticNode.recordQueryResult(resources, CosmosDbDiagnosticLevel.debugUnsafe);\n          responseHeaders = response.headers;\n          this.continuationToken = responseHeaders[Constants.HttpHeaders.Continuation];\n          if (!this.continuationToken) {\n            ++this.currentPartitionIndex;\n          }\n\n          if (this.options && this.options.bufferItems === true) {\n            const fetchFunction = this.fetchFunctions[this.currentPartitionIndex];\n            this.nextFetchFunction = fetchFunction\n              ? fetchFunction(childDiagnosticNode, {\n                  ...this.options,\n                  continuationToken: this.continuationToken,\n                })\n              : undefined;\n          }\n        } catch (err: any) {\n          this.state = DefaultQueryExecutionContext.STATES.ended;\n          // return callback(err, undefined, responseHeaders);\n          // TODO: Error and data being returned is an antipattern, this might broken\n          throw err;\n        }\n\n        this.state = DefaultQueryExecutionContext.STATES.inProgress;\n        this.currentIndex = 0;\n        this.options.continuationToken = originalContinuation;\n        this.options.continuation = originalContinuation;\n\n        // deserializing query metrics so that we aren't working with delimited strings in the rest of the code base\n        if (Constants.HttpHeaders.QueryMetrics in responseHeaders) {\n          const delimitedString = responseHeaders[Constants.HttpHeaders.QueryMetrics];\n          let queryMetrics = QueryMetrics.createFromDelimitedString(delimitedString);\n\n          // Add the request charge to the query metrics so that we can have per partition request charge.\n          if (Constants.HttpHeaders.RequestCharge in responseHeaders) {\n            const requestCharge = Number(responseHeaders[Constants.HttpHeaders.RequestCharge]) || 0;\n            queryMetrics = new QueryMetrics(\n              queryMetrics.retrievedDocumentCount,\n              queryMetrics.retrievedDocumentSize,\n              queryMetrics.outputDocumentCount,\n              queryMetrics.outputDocumentSize,\n              queryMetrics.indexHitDocumentCount,\n              queryMetrics.totalQueryExecutionTime,\n              queryMetrics.queryPreparationTimes,\n              queryMetrics.indexLookupTime,\n              queryMetrics.documentLoadTime,\n              queryMetrics.vmExecutionTime,\n              queryMetrics.runtimeExecutionTimes,\n              queryMetrics.documentWriteTime,\n              new ClientSideMetrics(requestCharge),\n            );\n          }\n\n          // Wraping query metrics in a object where the key is '0' just so single partition\n          // and partition queries have the same response schema\n          responseHeaders[Constants.HttpHeaders.QueryMetrics] = {};\n          responseHeaders[Constants.HttpHeaders.QueryMetrics][\"0\"] = queryMetrics;\n        }\n\n        if (operationOptions && operationOptions.ruCapPerOperation && ruConsumedManager) {\n          await ruConsumedManager.addToRUConsumed(getRequestChargeIfAny(responseHeaders));\n          const ruConsumedValue = await ruConsumedManager.getRUConsumed();\n          if (ruConsumedValue > operationOptions.ruCapPerOperation) {\n            // For RUCapPerOperationExceededError error, we won't be updating the state from\n            // inProgress as we want to support continue\n            throw new RUCapPerOperationExceededError(\n              \"Request Unit limit per Operation call exceeded\",\n              resources,\n            );\n          }\n        }\n        return { result: resources, headers: responseHeaders };\n      },\n      diagnosticNode,\n      DiagnosticNodeType.DEFAULT_QUERY_NODE,\n      {\n        queryMethodIdentifier: \"fetchMore\",\n      },\n    );\n  }\n\n  private _canFetchMore(): boolean {\n    const res =\n      this.state === DefaultQueryExecutionContext.STATES.start ||\n      (this.continuationToken && this.state === DefaultQueryExecutionContext.STATES.inProgress) ||\n      (this.currentPartitionIndex < this.fetchFunctions.length &&\n        this.state === DefaultQueryExecutionContext.STATES.inProgress);\n    return res;\n  }\n}\n"]}