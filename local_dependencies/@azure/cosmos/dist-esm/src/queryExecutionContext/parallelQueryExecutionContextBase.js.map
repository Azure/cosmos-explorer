{"version":3,"file":"parallelQueryExecutionContextBase.js","sourceRoot":"","sources":["../../../src/queryExecutionContext/parallelQueryExecutionContextBase.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport PriorityQueue from \"priorityqueuejs\";\nimport { ClientContext } from \"../ClientContext\";\nimport { AzureLogger, createClientLogger } from \"@azure/logger\";\nimport { StatusCodes, SubStatusCodes, RUConsumedManager } from \"../common\";\nimport { FeedOptions, QueryOperationOptions, Response } from \"../request\";\nimport { PartitionedQueryExecutionInfo } from \"../request/ErrorResponse\";\nimport { QueryRange } from \"../routing/QueryRange\";\nimport { SmartRoutingMapProvider } from \"../routing/smartRoutingMapProvider\";\nimport { CosmosHeaders } from \"./CosmosHeaders\";\nimport { DocumentProducer } from \"./documentProducer\";\nimport { ExecutionContext } from \"./ExecutionContext\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport { SqlQuerySpec } from \"./SqlQuerySpec\";\nimport { DiagnosticNodeInternal, DiagnosticNodeType } from \"../diagnostics/DiagnosticNodeInternal\";\nimport { addDignosticChild } from \"../utils/diagnostics\";\nimport { MetadataLookUpType } from \"../CosmosDiagnostics\";\nimport { CosmosDbDiagnosticLevel } from \"../diagnostics/CosmosDbDiagnosticLevel\";\nimport {\n  RUCapPerOperationExceededError,\n  RUCapPerOperationExceededErrorCode,\n} from \"../request/RUCapPerOperationExceededError\";\nimport semaphore from \"semaphore\";\n\n/** @hidden */\nconst logger: AzureLogger = createClientLogger(\"parallelQueryExecutionContextBase\");\n\n/** @hidden */\nexport enum ParallelQueryExecutionContextBaseStates {\n  started = \"started\",\n  inProgress = \"inProgress\",\n  ended = \"ended\",\n}\n\n/** @hidden */\nexport abstract class ParallelQueryExecutionContextBase implements ExecutionContext {\n  private err: any;\n  private state: any;\n  private static STATES = ParallelQueryExecutionContextBaseStates;\n  private routingProvider: SmartRoutingMapProvider;\n  protected sortOrders: any;\n  private requestContinuation: any;\n  private respHeaders: CosmosHeaders;\n  private orderByPQ: PriorityQueue<DocumentProducer>;\n  private diagnosticNodeWrapper: {\n    consumed: boolean;\n    diagnosticNode: DiagnosticNodeInternal;\n  };\n  private initializedPriorityQueue: boolean = false;\n  private ruCapExceededError: RUCapPerOperationExceededError = undefined;\n  /**\n   * Semaphore for Controlling Concurrent Access to the `nextItem` Method\n   *\n   * serializes access to the `nextItem` method,\n   * preventing concurrent issues during initialization, document producer\n   * handling, diagnostic node updates, and error propagation.\n   */\n  private nextItemfetchSemaphore;\n  /**\n   * Provides the ParallelQueryExecutionContextBase.\n   * This is the base class that ParallelQueryExecutionContext and OrderByQueryExecutionContext will derive from.\n   *\n   * When handling a parallelized query, it instantiates one instance of\n   * DocumentProcuder per target partition key range and aggregates the result of each.\n   *\n   * @param clientContext - The service endpoint to use to create the client.\n   * @param collectionLink - The Collection Link\n   * @param options - Represents the feed options.\n   * @param partitionedQueryExecutionInfo - PartitionedQueryExecutionInfo\n   * @hidden\n   */\n  constructor(\n    private clientContext: ClientContext,\n    private collectionLink: string,\n    private query: string | SqlQuerySpec,\n    private options: FeedOptions,\n    private partitionedQueryExecutionInfo: PartitionedQueryExecutionInfo,\n  ) {\n    this.clientContext = clientContext;\n    this.collectionLink = collectionLink;\n    this.query = query;\n    this.options = options;\n    this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;\n    this.diagnosticNodeWrapper = {\n      consumed: false,\n      diagnosticNode: new DiagnosticNodeInternal(\n        clientContext.diagnosticLevel,\n        DiagnosticNodeType.PARALLEL_QUERY_NODE,\n        null,\n      ),\n    };\n    this.diagnosticNodeWrapper.diagnosticNode.addData({ stateful: true });\n    this.err = undefined;\n    this.state = ParallelQueryExecutionContextBase.STATES.started;\n    this.routingProvider = new SmartRoutingMapProvider(this.clientContext);\n    this.sortOrders = this.partitionedQueryExecutionInfo.queryInfo.orderBy;\n\n    this.requestContinuation = options ? options.continuationToken || options.continuation : null;\n    // response headers of undergoing operation\n    this.respHeaders = getInitialHeader();\n\n    // Make priority queue for documentProducers\n    // The comparator is supplied by the derived class\n    this.orderByPQ = new PriorityQueue<DocumentProducer>(\n      (a: DocumentProducer, b: DocumentProducer) => this.documentProducerComparator(b, a),\n    );\n    this.nextItemfetchSemaphore = semaphore(1);\n  }\n\n  protected abstract documentProducerComparator(\n    dp1: DocumentProducer,\n    dp2: DocumentProducer,\n  ): number;\n\n  private _mergeWithActiveResponseHeaders(headers: CosmosHeaders): void {\n    mergeHeaders(this.respHeaders, headers);\n  }\n\n  private _getAndResetActiveResponseHeaders(): CosmosHeaders {\n    const ret = this.respHeaders;\n    this.respHeaders = getInitialHeader();\n    return ret;\n  }\n\n  private getDiagnosticNode(): DiagnosticNodeInternal {\n    return this.diagnosticNodeWrapper.diagnosticNode;\n  }\n\n  private async _onTargetPartitionRanges(): Promise<any[]> {\n    // invokes the callback when the target partition ranges are ready\n    const parsedRanges = this.partitionedQueryExecutionInfo.queryRanges;\n    const queryRanges = parsedRanges.map((item) => QueryRange.parseFromDict(item));\n    return this.routingProvider.getOverlappingRanges(\n      this.collectionLink,\n      queryRanges,\n      this.getDiagnosticNode(),\n    );\n  }\n\n  /**\n   * Gets the replacement ranges for a partitionkeyrange that has been split\n   */\n  private async _getReplacementPartitionKeyRanges(\n    documentProducer: DocumentProducer,\n  ): Promise<any[]> {\n    const partitionKeyRange = documentProducer.targetPartitionKeyRange;\n    // Download the new routing map\n    this.routingProvider = new SmartRoutingMapProvider(this.clientContext);\n    // Get the queryRange that relates to this partitionKeyRange\n    const queryRange = QueryRange.parsePartitionKeyRange(partitionKeyRange);\n    return this.routingProvider.getOverlappingRanges(\n      this.collectionLink,\n      [queryRange],\n      this.getDiagnosticNode(),\n    );\n  }\n\n  // TODO: P0 Code smell - can barely tell what this is doing\n  /**\n   * Removes the current document producer from the priqueue,\n   * replaces that document producer with child document producers,\n   * then reexecutes the originFunction with the corrrected executionContext\n   */\n  private async _repairExecutionContext(\n    diagnosticNode: DiagnosticNodeInternal,\n    originFunction: any,\n  ): Promise<void> {\n    // TODO: any\n    // Get the replacement ranges\n    // Removing the invalid documentProducer from the orderByPQ\n    const parentDocumentProducer = this.orderByPQ.deq();\n    try {\n      const replacementPartitionKeyRanges: any[] =\n        await this._getReplacementPartitionKeyRanges(parentDocumentProducer);\n      const replacementDocumentProducers: DocumentProducer[] = [];\n      // Create the replacement documentProducers\n      replacementPartitionKeyRanges.forEach((partitionKeyRange) => {\n        // Create replacment document producers with the parent's continuationToken\n        const replacementDocumentProducer = this._createTargetPartitionQueryExecutionContext(\n          partitionKeyRange,\n          parentDocumentProducer.continuationToken,\n        );\n        replacementDocumentProducers.push(replacementDocumentProducer);\n      });\n      // We need to check if the documentProducers even has anything left to fetch from before enqueing them\n      const checkAndEnqueueDocumentProducer = async (\n        documentProducerToCheck: DocumentProducer,\n        checkNextDocumentProducerCallback: any,\n      ): Promise<void> => {\n        try {\n          const { result: afterItem } = await documentProducerToCheck.current(diagnosticNode);\n          if (afterItem === undefined) {\n            // no more results left in this document producer, so we don't enqueue it\n          } else {\n            // Safe to put document producer back in the queue\n            this.orderByPQ.enq(documentProducerToCheck);\n          }\n\n          await checkNextDocumentProducerCallback();\n        } catch (err: any) {\n          this.err = err;\n          return;\n        }\n      };\n      const checkAndEnqueueDocumentProducers = async (rdp: DocumentProducer[]): Promise<any> => {\n        if (rdp.length > 0) {\n          // We still have a replacementDocumentProducer to check\n          const replacementDocumentProducer = rdp.shift();\n          await checkAndEnqueueDocumentProducer(replacementDocumentProducer, async () => {\n            await checkAndEnqueueDocumentProducers(rdp);\n          });\n        } else {\n          // reexecutes the originFunction with the corrrected executionContext\n          return originFunction();\n        }\n      };\n      // Invoke the recursive function to get the ball rolling\n      await checkAndEnqueueDocumentProducers(replacementDocumentProducers);\n    } catch (err: any) {\n      this.err = err;\n      throw err;\n    }\n  }\n\n  private static _needPartitionKeyRangeCacheRefresh(error: any): boolean {\n    // TODO: any error\n    return (\n      error.code === StatusCodes.Gone &&\n      \"substatus\" in error &&\n      error[\"substatus\"] === SubStatusCodes.PartitionKeyRangeGone\n    );\n  }\n\n  /**\n   * Checks to see if the executionContext needs to be repaired.\n   * if so it repairs the execution context and executes the ifCallback,\n   * else it continues with the current execution context and executes the elseCallback\n   */\n  private async _repairExecutionContextIfNeeded(\n    diagnosticNode: DiagnosticNodeInternal,\n    ifCallback: any,\n    elseCallback: any,\n    operationOptions?: QueryOperationOptions,\n    ruConsumedManager?: RUConsumedManager,\n  ): Promise<void> {\n    const documentProducer = this.orderByPQ.peek();\n    // Check if split happened\n    try {\n      await documentProducer.current(diagnosticNode, operationOptions, ruConsumedManager);\n      elseCallback();\n    } catch (err: any) {\n      if (ParallelQueryExecutionContextBase._needPartitionKeyRangeCacheRefresh(err)) {\n        // Split has happened so we need to repair execution context before continueing\n        return addDignosticChild(\n          (childNode) => this._repairExecutionContext(childNode, ifCallback),\n          diagnosticNode,\n          DiagnosticNodeType.QUERY_REPAIR_NODE,\n        );\n      } else {\n        // Something actually bad happened ...\n        this.err = err;\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Fetches the next element in the ParallelQueryExecutionContextBase.\n   */\n  public async nextItem(\n    diagnosticNode: DiagnosticNodeInternal,\n    operationOptions?: QueryOperationOptions,\n    ruConsumedManager?: RUConsumedManager,\n  ): Promise<Response<any>> {\n    if (this.err) {\n      // if there is a prior error return error\n      throw this.err;\n    }\n    return new Promise<Response<any>>((resolve, reject) => {\n      this.nextItemfetchSemaphore.take(async () => {\n        // document producer queue initilization\n        if (!this.initializedPriorityQueue) {\n          try {\n            await this._createDocumentProducersAndFillUpPriorityQueue(\n              operationOptions,\n              ruConsumedManager,\n            );\n            this.initializedPriorityQueue = true;\n          } catch (err: any) {\n            this.err = err;\n            // release the lock before invoking callback\n            this.nextItemfetchSemaphore.leave();\n            reject(this.err);\n            return;\n          }\n        }\n\n        if (!this.diagnosticNodeWrapper.consumed) {\n          diagnosticNode.addChildNode(\n            this.diagnosticNodeWrapper.diagnosticNode,\n            CosmosDbDiagnosticLevel.debug,\n            MetadataLookUpType.QueryPlanLookUp,\n          );\n          this.diagnosticNodeWrapper.diagnosticNode = undefined;\n          this.diagnosticNodeWrapper.consumed = true;\n        } else {\n          this.diagnosticNodeWrapper.diagnosticNode = diagnosticNode;\n        }\n        // NOTE: lock must be released before invoking quitting\n        if (this.err) {\n          // release the lock before invoking callback\n          this.nextItemfetchSemaphore.leave();\n          this.err.headers = this._getAndResetActiveResponseHeaders();\n          reject(this.err);\n          return;\n        }\n\n        if (this.orderByPQ.size() === 0) {\n          // there is no more results\n          this.state = ParallelQueryExecutionContextBase.STATES.ended;\n          // release the lock before invoking callback\n          this.nextItemfetchSemaphore.leave();\n          return resolve({\n            result: undefined,\n            headers: this._getAndResetActiveResponseHeaders(),\n          });\n        }\n\n        const ifCallback = (): void => {\n          // Release the semaphore to avoid deadlock\n          this.nextItemfetchSemaphore.leave();\n          // Reexcute the function\n          return resolve(this.nextItem(diagnosticNode, operationOptions, ruConsumedManager));\n        };\n        const elseCallback = async (): Promise<void> => {\n          let documentProducer: DocumentProducer;\n          try {\n            documentProducer = this.orderByPQ.deq();\n          } catch (e: any) {\n            // if comparing elements of the priority queue throws exception\n            // set that error and return error\n            this.err = e;\n            // release the lock before invoking callback\n            this.nextItemfetchSemaphore.leave();\n            this.err.headers = this._getAndResetActiveResponseHeaders();\n            reject(this.err);\n            return;\n          }\n\n          let item: any;\n          let headers: CosmosHeaders;\n          try {\n            const response = await documentProducer.nextItem(\n              diagnosticNode,\n              operationOptions,\n              ruConsumedManager,\n            );\n            item = response.result;\n            headers = response.headers;\n            this._mergeWithActiveResponseHeaders(headers);\n            if (item === undefined) {\n              // this should never happen\n              // because the documentProducer already has buffered an item\n              // assert item !== undefined\n              this.err = new Error(\n                `Extracted DocumentProducer from the priority queue \\\n                                            doesn't have any buffered item!`,\n              );\n              // release the lock before invoking callback\n              this.nextItemfetchSemaphore.leave();\n              return resolve({\n                result: undefined,\n                headers: this._getAndResetActiveResponseHeaders(),\n              });\n            }\n          } catch (err: any) {\n            if (err.code === RUCapPerOperationExceededErrorCode) {\n              this._updateErrorObjectWithBufferedData(err);\n              this.err = err;\n            } else {\n              this.err = new Error(\n                `Extracted DocumentProducer from the priority queue fails to get the \\\n                                    buffered item. Due to ${JSON.stringify(err)}`,\n              );\n              this.err.headers = this._getAndResetActiveResponseHeaders();\n            }\n            // release the lock before invoking callback\n            this.nextItemfetchSemaphore.leave();\n            reject(this.err);\n            return;\n          }\n\n          // we need to put back the document producer to the queue if it has more elements.\n          // the lock will be released after we know document producer must be put back in the queue or not\n          try {\n            const { result: afterItem, headers: otherHeaders } = await documentProducer.current(\n              diagnosticNode,\n              operationOptions,\n              ruConsumedManager,\n            );\n            this._mergeWithActiveResponseHeaders(otherHeaders);\n            if (afterItem === undefined) {\n              // no more results is left in this document producer\n            } else {\n              try {\n                const headItem = documentProducer.fetchResults[0];\n                if (typeof headItem === \"undefined\") {\n                  throw new Error(\n                    \"Extracted DocumentProducer from PQ is invalid state with no result!\",\n                  );\n                }\n                this.orderByPQ.enq(documentProducer);\n              } catch (e: any) {\n                // if comparing elements in priority queue throws exception\n                // set error\n                this.err = e;\n              }\n            }\n          } catch (err: any) {\n            if (ParallelQueryExecutionContextBase._needPartitionKeyRangeCacheRefresh(err)) {\n              // We want the document producer enqueued\n              // So that later parts of the code can repair the execution context\n              this.orderByPQ.enq(documentProducer);\n            } else if (err.code === RUCapPerOperationExceededErrorCode) {\n              this._updateErrorObjectWithBufferedData(err);\n              this.err = err;\n              reject(this.err);\n            } else {\n              // Something actually bad happened\n              this.err = err;\n              reject(this.err);\n            }\n          } finally {\n            // release the lock before returning\n            this.nextItemfetchSemaphore.leave();\n          }\n          // invoke the callback on the item\n          return resolve({\n            result: item,\n            headers: this._getAndResetActiveResponseHeaders(),\n          });\n        };\n        this._repairExecutionContextIfNeeded(diagnosticNode, ifCallback, elseCallback).catch(\n          reject,\n        );\n      });\n    });\n  }\n\n  private _updateErrorObjectWithBufferedData(err: any) {\n    this.orderByPQ.forEach((dp) => {\n      const bufferedItems = dp.peekBufferedItems();\n      err.fetchedResults.push(...bufferedItems);\n    });\n  }\n\n  /**\n   * Determine if there are still remaining resources to processs based on the value of the continuation\n   * token or the elements remaining on the current batch in the QueryIterator.\n   * @returns true if there is other elements to process in the ParallelQueryExecutionContextBase.\n   */\n  public hasMoreResults(): boolean {\n    return !(\n      this.state === ParallelQueryExecutionContextBase.STATES.ended || this.err !== undefined\n    );\n  }\n\n  /**\n   * Creates document producers\n   */\n  private _createTargetPartitionQueryExecutionContext(\n    partitionKeyTargetRange: any,\n    continuationToken?: any,\n  ): DocumentProducer {\n    // TODO: any\n    // creates target partition range Query Execution Context\n    let rewrittenQuery = this.partitionedQueryExecutionInfo.queryInfo.rewrittenQuery;\n    let sqlQuerySpec: SqlQuerySpec;\n    const query = this.query;\n    if (typeof query === \"string\") {\n      sqlQuerySpec = { query };\n    } else {\n      sqlQuerySpec = query;\n    }\n\n    const formatPlaceHolder = \"{documentdb-formattableorderbyquery-filter}\";\n    if (rewrittenQuery) {\n      sqlQuerySpec = JSON.parse(JSON.stringify(sqlQuerySpec));\n      // We hardcode the formattable filter to true for now\n      rewrittenQuery = rewrittenQuery.replace(formatPlaceHolder, \"true\");\n      sqlQuerySpec[\"query\"] = rewrittenQuery;\n    }\n\n    const options = { ...this.options };\n    options.continuationToken = continuationToken;\n\n    return new DocumentProducer(\n      this.clientContext,\n      this.collectionLink,\n      sqlQuerySpec,\n      partitionKeyTargetRange,\n      options,\n    );\n  }\n\n  private async _createDocumentProducersAndFillUpPriorityQueue(\n    operationOptions?: QueryOperationOptions,\n    ruConsumedManager?: RUConsumedManager,\n  ): Promise<void> {\n    try {\n      const targetPartitionRanges = await this._onTargetPartitionRanges();\n      const maxDegreeOfParallelism =\n        this.options.maxDegreeOfParallelism === undefined || this.options.maxDegreeOfParallelism < 1\n          ? targetPartitionRanges.length\n          : Math.min(this.options.maxDegreeOfParallelism, targetPartitionRanges.length);\n\n      logger.info(\n        \"Query starting against \" +\n          targetPartitionRanges.length +\n          \" ranges with parallelism of \" +\n          maxDegreeOfParallelism,\n      );\n\n      let filteredPartitionKeyRanges = [];\n      // The document producers generated from filteredPartitionKeyRanges\n      const targetPartitionQueryExecutionContextList: DocumentProducer[] = [];\n\n      if (this.requestContinuation) {\n        throw new Error(\"Continuation tokens are not yet supported for cross partition queries\");\n      } else {\n        filteredPartitionKeyRanges = targetPartitionRanges;\n      }\n\n      // Create one documentProducer for each partitionTargetRange\n      filteredPartitionKeyRanges.forEach((partitionTargetRange: any) => {\n        // TODO: any partitionTargetRange\n        // no async callback\n        targetPartitionQueryExecutionContextList.push(\n          this._createTargetPartitionQueryExecutionContext(partitionTargetRange),\n        );\n      });\n\n      // Fill up our priority queue with documentProducers\n      let inProgressPromises: Promise<void>[] = [];\n      for (const documentProducer of targetPartitionQueryExecutionContextList) {\n        // Don't enqueue any new promise if RU cap exceeded\n        if (this.ruCapExceededError) {\n          break;\n        }\n        const promise: Promise<void> = this._processAndEnqueueDocumentProducer(\n          documentProducer,\n          operationOptions,\n          ruConsumedManager,\n        );\n        inProgressPromises.push(promise);\n\n        // Limit concurrent executions\n        if (inProgressPromises.length === maxDegreeOfParallelism) {\n          await Promise.all(inProgressPromises);\n          inProgressPromises = [];\n        }\n      }\n      // Wait for all promises to complete\n      await Promise.all(inProgressPromises);\n      if (this.err) {\n        if (this.ruCapExceededError) {\n          // merge the buffered items\n          this.orderByPQ.forEach((dp) => {\n            const bufferedItems = dp.peekBufferedItems();\n            this.ruCapExceededError.fetchedResults.push(...bufferedItems);\n          });\n          throw this.ruCapExceededError;\n        }\n        throw this.err;\n      }\n    } catch (err: any) {\n      this.err = err;\n      throw err;\n    }\n  }\n\n  private async _processAndEnqueueDocumentProducer(\n    documentProducer: DocumentProducer,\n    operationOptions?: QueryOperationOptions,\n    ruConsumedManager?: RUConsumedManager,\n  ): Promise<void> {\n    try {\n      const { result: document, headers } = await documentProducer.current(\n        this.getDiagnosticNode(),\n        operationOptions,\n        ruConsumedManager,\n      );\n      this._mergeWithActiveResponseHeaders(headers);\n\n      if (document !== undefined) {\n        this.orderByPQ.enq(documentProducer);\n      }\n    } catch (err) {\n      this._mergeWithActiveResponseHeaders(err.headers);\n      this.err = err;\n      if (err.code === RUCapPerOperationExceededErrorCode) {\n        // would be halting further execution of other promises\n        if (!this.ruCapExceededError) {\n          this.ruCapExceededError = err;\n        } else {\n          // merge the buffered items\n          if (err.fetchedResults) {\n            this.ruCapExceededError.fetchedResults.push(...err.fetchedResults);\n          }\n        }\n      } else {\n        throw err;\n      }\n    }\n    return;\n  }\n}\n"]}