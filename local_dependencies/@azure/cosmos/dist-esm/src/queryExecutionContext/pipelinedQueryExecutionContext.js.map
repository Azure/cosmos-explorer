{"version":3,"file":"pipelinedQueryExecutionContext.js","sourceRoot":"","sources":["../../../src/queryExecutionContext/pipelinedQueryExecutionContext.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { ClientContext } from \"../ClientContext\";\nimport { Response, FeedOptions, QueryOperationOptions } from \"../request\";\nimport { PartitionedQueryExecutionInfo, QueryInfo } from \"../request/ErrorResponse\";\nimport { CosmosHeaders } from \"./CosmosHeaders\";\nimport { OffsetLimitEndpointComponent } from \"./EndpointComponent/OffsetLimitEndpointComponent\";\nimport { OrderByEndpointComponent } from \"./EndpointComponent/OrderByEndpointComponent\";\nimport { OrderedDistinctEndpointComponent } from \"./EndpointComponent/OrderedDistinctEndpointComponent\";\nimport { UnorderedDistinctEndpointComponent } from \"./EndpointComponent/UnorderedDistinctEndpointComponent\";\nimport { GroupByEndpointComponent } from \"./EndpointComponent/GroupByEndpointComponent\";\nimport { ExecutionContext } from \"./ExecutionContext\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport { OrderByQueryExecutionContext } from \"./orderByQueryExecutionContext\";\nimport { ParallelQueryExecutionContext } from \"./parallelQueryExecutionContext\";\nimport { GroupByValueEndpointComponent } from \"./EndpointComponent/GroupByValueEndpointComponent\";\nimport { SqlQuerySpec } from \"./SqlQuerySpec\";\nimport { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal\";\nimport { RUCapPerOperationExceededErrorCode } from \"../request/RUCapPerOperationExceededError\";\nimport { Constants, RUConsumedManager } from \"../common\";\nimport { NonStreamingOrderByDistinctEndpointComponent } from \"./EndpointComponent/NonStreamingOrderByDistinctEndpointComponent\";\nimport { NonStreamingOrderByEndpointComponent } from \"./EndpointComponent/NonStreamingOrderByEndpointComponent\";\n\n/** @hidden */\nexport class PipelinedQueryExecutionContext implements ExecutionContext {\n  private fetchBuffer: any[];\n  private fetchMoreRespHeaders: CosmosHeaders;\n  private endpoint: ExecutionContext;\n  private pageSize: number;\n  private vectorSearchBufferSize: number = 0;\n  private static DEFAULT_PAGE_SIZE = 10;\n  private static DEFAULT_VECTOR_SEARCH_BUFFER_SIZE = 2000;\n  private nonStreamingOrderBy = false;\n\n  constructor(\n    private clientContext: ClientContext,\n    private collectionLink: string,\n    private query: string | SqlQuerySpec,\n    private options: FeedOptions,\n    private partitionedQueryExecutionInfo: PartitionedQueryExecutionInfo,\n  ) {\n    this.endpoint = null;\n    this.pageSize = options[\"maxItemCount\"];\n    if (this.pageSize === undefined) {\n      this.pageSize = PipelinedQueryExecutionContext.DEFAULT_PAGE_SIZE;\n    }\n    // Pick between Nonstreaming and streaming endpoints\n    this.nonStreamingOrderBy = partitionedQueryExecutionInfo.queryInfo.hasNonStreamingOrderBy;\n\n    // Pick between parallel vs order by execution context\n    const sortOrders = partitionedQueryExecutionInfo.queryInfo.orderBy;\n    // TODO: Currently we don't get any field from backend to determine streaming queries\n    if (this.nonStreamingOrderBy) {\n      this.vectorSearchBufferSize = this.calculateVectorSearchBufferSize(\n        partitionedQueryExecutionInfo.queryInfo,\n        options,\n      );\n\n      const distinctType = partitionedQueryExecutionInfo.queryInfo.distinctType;\n      const context: ExecutionContext = new ParallelQueryExecutionContext(\n        this.clientContext,\n        this.collectionLink,\n        this.query,\n        this.options,\n        this.partitionedQueryExecutionInfo,\n      );\n\n      if (distinctType === \"None\") {\n        this.endpoint = new NonStreamingOrderByEndpointComponent(\n          context,\n          sortOrders,\n          this.vectorSearchBufferSize,\n          partitionedQueryExecutionInfo.queryInfo.offset,\n        );\n      } else {\n        this.endpoint = new NonStreamingOrderByDistinctEndpointComponent(\n          context,\n          partitionedQueryExecutionInfo.queryInfo,\n          this.vectorSearchBufferSize,\n        );\n      }\n    } else {\n      if (Array.isArray(sortOrders) && sortOrders.length > 0) {\n        // Need to wrap orderby execution context in endpoint component, since the data is nested as a \\\n        //      \"payload\" property.\n        this.endpoint = new OrderByEndpointComponent(\n          new OrderByQueryExecutionContext(\n            this.clientContext,\n            this.collectionLink,\n            this.query,\n            this.options,\n            this.partitionedQueryExecutionInfo,\n          ),\n        );\n      } else {\n        this.endpoint = new ParallelQueryExecutionContext(\n          this.clientContext,\n          this.collectionLink,\n          this.query,\n          this.options,\n          this.partitionedQueryExecutionInfo,\n        );\n      }\n      if (\n        Object.keys(partitionedQueryExecutionInfo.queryInfo.groupByAliasToAggregateType).length >\n          0 ||\n        partitionedQueryExecutionInfo.queryInfo.aggregates.length > 0 ||\n        partitionedQueryExecutionInfo.queryInfo.groupByExpressions.length > 0\n      ) {\n        if (partitionedQueryExecutionInfo.queryInfo.hasSelectValue) {\n          this.endpoint = new GroupByValueEndpointComponent(\n            this.endpoint,\n            partitionedQueryExecutionInfo.queryInfo,\n          );\n        } else {\n          this.endpoint = new GroupByEndpointComponent(\n            this.endpoint,\n            partitionedQueryExecutionInfo.queryInfo,\n          );\n        }\n      }\n      // If top then add that to the pipeline. TOP N is effectively OFFSET 0 LIMIT N\n      const top = partitionedQueryExecutionInfo.queryInfo.top;\n      if (typeof top === \"number\") {\n        this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, 0, top);\n      }\n\n      // If offset+limit then add that to the pipeline\n      const limit = partitionedQueryExecutionInfo.queryInfo.limit;\n      const offset = partitionedQueryExecutionInfo.queryInfo.offset;\n      if (typeof limit === \"number\" && typeof offset === \"number\") {\n        this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, offset, limit);\n      }\n\n      // If distinct then add that to the pipeline\n      const distinctType = partitionedQueryExecutionInfo.queryInfo.distinctType;\n      if (distinctType === \"Ordered\") {\n        this.endpoint = new OrderedDistinctEndpointComponent(this.endpoint);\n      }\n      if (distinctType === \"Unordered\") {\n        this.endpoint = new UnorderedDistinctEndpointComponent(this.endpoint);\n      }\n    }\n  }\n\n  public async nextItem(\n    diagnosticNode: DiagnosticNodeInternal,\n    operationOptions?: QueryOperationOptions,\n    ruConsumedManager?: RUConsumedManager,\n  ): Promise<Response<any>> {\n    return this.endpoint.nextItem(diagnosticNode, operationOptions, ruConsumedManager);\n  }\n\n  // Removed callback here beacuse it wouldn't have ever worked...\n  public hasMoreResults(): boolean {\n    return this.endpoint.hasMoreResults();\n  }\n\n  public async fetchMore(\n    diagnosticNode: DiagnosticNodeInternal,\n    operationOptions?: QueryOperationOptions,\n    ruConsumedManager?: RUConsumedManager,\n  ): Promise<Response<any>> {\n    // if the wrapped endpoint has different implementation for fetchMore use that\n    // otherwise use the default implementation\n    if (typeof this.endpoint.fetchMore === \"function\") {\n      return this.endpoint.fetchMore(diagnosticNode, operationOptions, ruConsumedManager);\n    } else {\n      this.fetchBuffer = [];\n      this.fetchMoreRespHeaders = getInitialHeader();\n      return this.nonStreamingOrderBy\n        ? this._nonStreamingFetchMoreImplementation(\n            diagnosticNode,\n            operationOptions,\n            ruConsumedManager,\n          )\n        : this._fetchMoreImplementation(diagnosticNode, operationOptions, ruConsumedManager);\n    }\n  }\n\n  private async _fetchMoreImplementation(\n    diagnosticNode: DiagnosticNodeInternal,\n    operationOptions?: QueryOperationOptions,\n    ruConsumedManager?: RUConsumedManager,\n  ): Promise<Response<any>> {\n    try {\n      const { result: item, headers } = await this.endpoint.nextItem(\n        diagnosticNode,\n        operationOptions,\n        ruConsumedManager,\n      );\n      mergeHeaders(this.fetchMoreRespHeaders, headers);\n      if (item === undefined) {\n        // no more results\n        if (this.fetchBuffer.length === 0) {\n          return {\n            result: undefined,\n            headers: this.fetchMoreRespHeaders,\n          };\n        } else {\n          // Just give what we have\n          const temp = this.fetchBuffer;\n          this.fetchBuffer = [];\n          return { result: temp, headers: this.fetchMoreRespHeaders };\n        }\n      } else {\n        this.fetchBuffer.push(item);\n        if (this.fetchBuffer.length >= this.pageSize) {\n          // fetched enough results\n          const temp = this.fetchBuffer.slice(0, this.pageSize);\n          this.fetchBuffer = this.fetchBuffer.splice(this.pageSize);\n          return { result: temp, headers: this.fetchMoreRespHeaders };\n        } else {\n          // recursively fetch more\n          // TODO: is recursion a good idea?\n          return this._fetchMoreImplementation(diagnosticNode, operationOptions, ruConsumedManager);\n        }\n      }\n    } catch (err: any) {\n      mergeHeaders(this.fetchMoreRespHeaders, err.headers);\n      err.headers = this.fetchMoreRespHeaders;\n      if (err.code === RUCapPerOperationExceededErrorCode && err.fetchedResults) {\n        err.fetchedResults.push(...this.fetchBuffer);\n      }\n      if (err) {\n        throw err;\n      }\n    }\n  }\n\n  private async _nonStreamingFetchMoreImplementation(\n    diagnosticNode: DiagnosticNodeInternal,\n    operationOptions?: QueryOperationOptions,\n    ruConsumedManager?: RUConsumedManager,\n  ): Promise<Response<any>> {\n    try {\n      const { result: item, headers } = await this.endpoint.nextItem(\n        diagnosticNode,\n        operationOptions,\n        ruConsumedManager,\n      );\n      mergeHeaders(this.fetchMoreRespHeaders, headers);\n      if (item === undefined) {\n        // no more results\n        if (this.fetchBuffer.length === 0) {\n          return {\n            result: undefined,\n            headers: this.fetchMoreRespHeaders,\n          };\n        } else {\n          // Just give what we have\n          const temp = this.fetchBuffer;\n          this.fetchBuffer = [];\n          return { result: temp, headers: this.fetchMoreRespHeaders };\n        }\n      } else {\n        const ruConsumed = await ruConsumedManager.getRUConsumed();\n        const maxRUAllowed =\n          operationOptions && operationOptions.ruCapPerOperation\n            ? operationOptions.ruCapPerOperation\n            : Constants.NonStreamingQueryDefaultRUThreshold;\n        // append the result\n        if (typeof item !== \"object\") {\n          this.fetchBuffer.push(item);\n        } else if (Object.keys(item).length !== 0) {\n          this.fetchBuffer.push(item);\n        }\n        if (this.fetchBuffer.length >= this.pageSize) {\n          // fetched enough results\n          const temp = this.fetchBuffer.slice(0, this.pageSize);\n          this.fetchBuffer = this.fetchBuffer.splice(this.pageSize);\n          return { result: temp, headers: this.fetchMoreRespHeaders };\n        } else if (ruConsumed * 2 < maxRUAllowed) {\n          // recursively fetch more only if we have more than 50% RUs left.\n          return this._nonStreamingFetchMoreImplementation(\n            diagnosticNode,\n            operationOptions,\n            ruConsumedManager,\n          );\n        } else {\n          return { result: [], headers: this.fetchMoreRespHeaders };\n        }\n      }\n    } catch (err: any) {\n      mergeHeaders(this.fetchMoreRespHeaders, err.headers);\n      err.headers = this.fetchMoreRespHeaders;\n      if (err.code === RUCapPerOperationExceededErrorCode && err.fetchedResults) {\n        err.fetchedResults.push(...this.fetchBuffer);\n      }\n      if (err) {\n        throw err;\n      }\n    }\n  }\n\n  private calculateVectorSearchBufferSize(queryInfo: QueryInfo, options: FeedOptions): number {\n    if (queryInfo.top === 0 || queryInfo.limit === 0) return 0;\n    return queryInfo.top\n      ? queryInfo.top\n      : queryInfo.limit\n        ? queryInfo.offset + queryInfo.limit\n        : options[\"vectorSearchBufferSize\"] && options[\"vectorSearchBufferSize\"] > 0\n          ? options[\"vectorSearchBufferSize\"]\n          : PipelinedQueryExecutionContext.DEFAULT_VECTOR_SEARCH_BUFFER_SIZE;\n  }\n}\n"]}