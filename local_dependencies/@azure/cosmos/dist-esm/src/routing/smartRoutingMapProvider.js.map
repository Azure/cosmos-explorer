{"version":3,"file":"smartRoutingMapProvider.js","sourceRoot":"","sources":["../../../src/routing/smartRoutingMapProvider.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,SAAS,EAAE,MAAM,qBAAqB,CAAC;AAEhD,OAAO,EAAE,sBAAsB,EAAE,MAAM,0BAA0B,CAAC;AAClE,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAE1C,cAAc;AACd,MAAM,CAAC,MAAM,gBAAgB,GAAG,SAAS,CAAC,iBAAiB,CAAC;AAE5D,cAAc;AACd,MAAM,OAAO,uBAAuB;IAGlC,YAAY,aAA4B;QACtC,IAAI,CAAC,sBAAsB,GAAG,IAAI,sBAAsB,CAAC,aAAa,CAAC,CAAC;IAC1E,CAAC;IACO,MAAM,CAAC,6BAA6B,CAAC,MAAkB,EAAE,MAAkB;QACjF,IAAI,OAAO,MAAM,CAAC,GAAG,KAAK,WAAW,EAAE;YACrC,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAC;SACzC;QAED,IAAI,OAAO,MAAM,CAAC,GAAG,KAAK,WAAW,EAAE;YACrC,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAC;SACzC;QAED,IAAI,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,EAAE;YAC3B,0BAA0B;YAC1B,OAAO,KAAK,CAAC;SACd;aAAM;YACL,IAAI,MAAM,CAAC,GAAG,KAAK,MAAM,CAAC,GAAG,IAAI,MAAM,CAAC,cAAc,IAAI,MAAM,CAAC,cAAc,EAAE;gBAC/E,mGAAmG;gBACnG,qBAAqB;gBACrB,OAAO,KAAK,CAAC;aACd;YACD,OAAO,IAAI,CAAC;SACb;IACH,CAAC;IAEO,MAAM,CAAC,0BAA0B,CAAC,MAAoB;QAC5D,KAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,GAAG,EAAE,EAAE;YAC5C,MAAM,SAAS,GAAG,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;YAClC,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;YACtB,IAAI,CAAC,IAAI,CAAC,6BAA6B,CAAC,SAAS,EAAE,CAAC,CAAC,EAAE;gBACrD,OAAO,KAAK,CAAC;aACd;SACF;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAEO,MAAM,CAAC,UAAU,CAAC,CAAS,EAAE,CAAS;QAC5C,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACxB,CAAC;IAEO,MAAM,CAAC,cAAc,CAAC,CAAS,EAAE,CAAS;QAChD,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACtC,CAAC;IAEO,MAAM,CAAC,cAAc,CAAC,CAAa,EAAE,iBAAsB;QACjE,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,iBAAiB,CAAC,gBAAgB,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC;QACtF,MAAM,aAAa,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,KAAK,CAAC;QACxF,OAAO,IAAI,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC,GAAG,EAAE,aAAa,EAAE,CAAC,CAAC,cAAc,CAAC,CAAC;IACtE,CAAC;IAED;;;;;OAKG;IACI,KAAK,CAAC,oBAAoB,CAC/B,cAAsB,EACtB,YAA0B,EAC1B,cAAsC;QAEtC,+GAA+G;QAC/G,IAAI,CAAC,uBAAuB,CAAC,0BAA0B,CAAC,YAAY,CAAC,EAAE;YACrE,MAAM,IAAI,KAAK,CAAC,2DAA2D,CAAC,CAAC;SAC9E;QAED,IAAI,kBAAkB,GAAU,EAAE,CAAC,CAAC,8BAA8B;QAElE,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE;YAC7B,OAAO,kBAAkB,CAAC;SAC3B;QAED,MAAM,oBAAoB,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,sBAAsB,CACnF,cAAc,EACd,cAAc,CACf,CAAC;QAEF,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,IAAI,oBAAoB,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC;QAC/C,SAAS;YACP,IAAI,oBAAoB,CAAC,OAAO,EAAE,EAAE;gBAClC,+BAA+B;gBAC/B,IAAI,EAAE,KAAK,IAAI,YAAY,CAAC,MAAM,EAAE;oBAClC,OAAO,kBAAkB,CAAC;iBAC3B;gBACD,oBAAoB,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC;gBAC3C,SAAS;aACV;YAED,IAAI,UAAU,CAAC;YACf,IAAI,kBAAkB,CAAC,MAAM,GAAG,CAAC,EAAE;gBACjC,UAAU,GAAG,uBAAuB,CAAC,cAAc,CACjD,oBAAoB,EACpB,kBAAkB,CAAC,kBAAkB,CAAC,MAAM,GAAG,CAAC,CAAC,CAClD,CAAC;aACH;iBAAM;gBACL,UAAU,GAAG,oBAAoB,CAAC;aACnC;YAED,MAAM,iBAAiB,GAAG,oBAAoB,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC;YAChF,IAAI,iBAAiB,CAAC,MAAM,IAAI,CAAC,EAAE;gBACjC,MAAM,IAAI,KAAK,CAAC,qDAAqD,UAAU,WAAW,CAAC,CAAC;aAC7F;YACD,kBAAkB,GAAG,kBAAkB,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC;YAElE,MAAM,oBAAoB,GAAG,UAAU,CAAC,sBAAsB,CAC5D,kBAAkB,CAAC,kBAAkB,CAAC,MAAM,GAAG,CAAC,CAAC,CAClD,CAAC;YACF,IAAI,CAAC,oBAAoB,EAAE;gBACzB,MAAM,IAAI,KAAK,CAAC,2CAA2C,CAAC,CAAC;aAC9D;YACD,0DAA0D;YAE1D,IACE,uBAAuB,CAAC,cAAc,CAAC,oBAAoB,CAAC,GAAG,EAAE,oBAAoB,CAAC,GAAG,CAAC;gBAC1F,CAAC,EACD;gBACA,MAAM,IAAI,KAAK,CAAC,sCAAsC,iBAAiB;+CAChC,UAAU,EAAE,CAAC,CAAC;aACtD;YAED,yEAAyE;YACzE,IAAI,EAAE,KAAK,IAAI,YAAY,CAAC,MAAM,EAAE;gBAClC,OAAO,kBAAkB,CAAC;aAC3B;YACD,oBAAoB,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC;YAE3C,OACE,uBAAuB,CAAC,cAAc,CACpC,oBAAoB,CAAC,GAAG,EACxB,oBAAoB,CAAC,GAAG,CACzB,IAAI,CAAC,EACN;gBACA,qDAAqD;gBACrD,IAAI,EAAE,KAAK,IAAI,YAAY,CAAC,MAAM,EAAE;oBAClC,OAAO,kBAAkB,CAAC;iBAC3B;gBACD,oBAAoB,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC;aAC5C;SACF;IACH,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { ClientContext } from \"../ClientContext\";\nimport { Constants } from \"../common/constants\";\nimport { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal\";\nimport { PartitionKeyRangeCache } from \"./partitionKeyRangeCache\";\nimport { QueryRange } from \"./QueryRange\";\n\n/** @hidden */\nexport const PARITIONKEYRANGE = Constants.PartitionKeyRange;\n\n/** @hidden */\nexport class SmartRoutingMapProvider {\n  private partitionKeyRangeCache: PartitionKeyRangeCache;\n\n  constructor(clientContext: ClientContext) {\n    this.partitionKeyRangeCache = new PartitionKeyRangeCache(clientContext);\n  }\n  private static _secondRangeIsAfterFirstRange(range1: QueryRange, range2: QueryRange): boolean {\n    if (typeof range1.max === \"undefined\") {\n      throw new Error(\"range1 must have max\");\n    }\n\n    if (typeof range2.min === \"undefined\") {\n      throw new Error(\"range2 must have min\");\n    }\n\n    if (range1.max > range2.min) {\n      // r.min < #previous_r.max\n      return false;\n    } else {\n      if (range1.max === range2.min && range1.isMaxInclusive && range2.isMinInclusive) {\n        // the inclusive ending endpoint of previous_r is the same as the inclusive beginning endpoint of r\n        // they share a point\n        return false;\n      }\n      return true;\n    }\n  }\n\n  private static _isSortedAndNonOverlapping(ranges: QueryRange[]): boolean {\n    for (let idx = 1; idx < ranges.length; idx++) {\n      const previousR = ranges[idx - 1];\n      const r = ranges[idx];\n      if (!this._secondRangeIsAfterFirstRange(previousR, r)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static _stringMax(a: string, b: string): string {\n    return a >= b ? a : b;\n  }\n\n  private static _stringCompare(a: string, b: string): 1 | 0 | -1 {\n    return a === b ? 0 : a > b ? 1 : -1;\n  }\n\n  private static _subtractRange(r: QueryRange, partitionKeyRange: any): QueryRange {\n    const left = this._stringMax(partitionKeyRange[PARITIONKEYRANGE.MaxExclusive], r.min);\n    const leftInclusive = this._stringCompare(left, r.min) === 0 ? r.isMinInclusive : false;\n    return new QueryRange(left, r.max, leftInclusive, r.isMaxInclusive);\n  }\n\n  /**\n   * Given the sorted ranges and a collection, invokes the callback on the list of overlapping partition key ranges\n   * @param callback - Function execute on the overlapping partition key ranges result,\n   *                   takes two parameters error, partition key ranges\n   * @hidden\n   */\n  public async getOverlappingRanges(\n    collectionLink: string,\n    sortedRanges: QueryRange[],\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<any[]> {\n    // validate if the list is non- overlapping and sorted                             TODO: any PartitionKeyRanges\n    if (!SmartRoutingMapProvider._isSortedAndNonOverlapping(sortedRanges)) {\n      throw new Error(\"the list of ranges is not a non-overlapping sorted ranges\");\n    }\n\n    let partitionKeyRanges: any[] = []; // TODO: any ParitionKeyRanges\n\n    if (sortedRanges.length === 0) {\n      return partitionKeyRanges;\n    }\n\n    const collectionRoutingMap = await this.partitionKeyRangeCache.onCollectionRoutingMap(\n      collectionLink,\n      diagnosticNode,\n    );\n\n    let index = 0;\n    let currentProvidedRange = sortedRanges[index];\n    for (;;) {\n      if (currentProvidedRange.isEmpty()) {\n        // skip and go to the next item\n        if (++index >= sortedRanges.length) {\n          return partitionKeyRanges;\n        }\n        currentProvidedRange = sortedRanges[index];\n        continue;\n      }\n\n      let queryRange;\n      if (partitionKeyRanges.length > 0) {\n        queryRange = SmartRoutingMapProvider._subtractRange(\n          currentProvidedRange,\n          partitionKeyRanges[partitionKeyRanges.length - 1],\n        );\n      } else {\n        queryRange = currentProvidedRange;\n      }\n\n      const overlappingRanges = collectionRoutingMap.getOverlappingRanges(queryRange);\n      if (overlappingRanges.length <= 0) {\n        throw new Error(`error: returned overlapping ranges for queryRange ${queryRange} is empty`);\n      }\n      partitionKeyRanges = partitionKeyRanges.concat(overlappingRanges);\n\n      const lastKnownTargetRange = QueryRange.parsePartitionKeyRange(\n        partitionKeyRanges[partitionKeyRanges.length - 1],\n      );\n      if (!lastKnownTargetRange) {\n        throw new Error(\"expected lastKnowTargetRange to be truthy\");\n      }\n      // the overlapping ranges must contain the requested range\n\n      if (\n        SmartRoutingMapProvider._stringCompare(currentProvidedRange.max, lastKnownTargetRange.max) >\n        0\n      ) {\n        throw new Error(`error: returned overlapping ranges ${overlappingRanges} \\\n        does not contain the requested range ${queryRange}`);\n      }\n\n      // the current range is contained in partitionKeyRanges just move forward\n      if (++index >= sortedRanges.length) {\n        return partitionKeyRanges;\n      }\n      currentProvidedRange = sortedRanges[index];\n\n      while (\n        SmartRoutingMapProvider._stringCompare(\n          currentProvidedRange.max,\n          lastKnownTargetRange.max,\n        ) <= 0\n      ) {\n        // the current range is covered too.just move forward\n        if (++index >= sortedRanges.length) {\n          return partitionKeyRanges;\n        }\n        currentProvidedRange = sortedRanges[index];\n      }\n    }\n  }\n}\n"]}