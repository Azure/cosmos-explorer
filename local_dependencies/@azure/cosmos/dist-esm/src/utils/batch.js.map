{"version":3,"file":"batch.js","sourceRoot":"","sources":["../../../src/utils/batch.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { JSONObject } from \"../queryExecutionContext\";\nimport { extractPartitionKeys } from \"../extractPartitionKey\";\nimport { CosmosDiagnostics, RequestOptions } from \"..\";\nimport {\n  NonePartitionKeyLiteral,\n  PartitionKey,\n  PartitionKeyDefinition,\n  PrimitivePartitionKeyValue,\n  convertToInternalPartitionKey,\n} from \"../documents\";\nimport { PatchRequestBody } from \"./patch\";\nimport { v4 } from \"uuid\";\nimport { assertNotUndefined } from \"./typeChecks\";\nimport { bodyFromData } from \"../request/request\";\nimport { Constants } from \"../common/constants\";\nconst uuid = v4;\n\nexport type Operation =\n  | CreateOperation\n  | UpsertOperation\n  | ReadOperation\n  | DeleteOperation\n  | ReplaceOperation\n  | BulkPatchOperation;\n\nexport interface Batch {\n  min: string;\n  max: string;\n  rangeId: string;\n  indexes: number[];\n  operations: Operation[];\n}\n\nexport type BulkOperationResponse = OperationResponse[] & { diagnostics: CosmosDiagnostics };\n\nexport interface OperationResponse {\n  statusCode: number;\n  requestCharge: number;\n  eTag?: string;\n  resourceBody?: JSONObject;\n}\n\n/**\n * Options object used to modify bulk execution.\n * continueOnError (Default value: false) - Continues bulk execution when an operation fails ** NOTE THIS WILL DEFAULT TO TRUE IN the 4.0 RELEASE\n */\nexport interface BulkOptions {\n  continueOnError?: boolean;\n}\n\nexport function isKeyInRange(min: string, max: string, key: string): boolean {\n  const isAfterMinInclusive = key.localeCompare(min) >= 0;\n  const isBeforeMax = key.localeCompare(max) < 0;\n  return isAfterMinInclusive && isBeforeMax;\n}\n\nexport interface OperationBase {\n  partitionKey?: string;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n}\n\nexport const BulkOperationType = {\n  Create: \"Create\",\n  Upsert: \"Upsert\",\n  Read: \"Read\",\n  Delete: \"Delete\",\n  Replace: \"Replace\",\n  Patch: \"Patch\",\n} as const;\n\nexport type OperationInput =\n  | CreateOperationInput\n  | UpsertOperationInput\n  | ReadOperationInput\n  | DeleteOperationInput\n  | ReplaceOperationInput\n  | PatchOperationInput;\n\nexport interface CreateOperationInput {\n  partitionKey?: PartitionKey;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Create;\n  resourceBody: JSONObject;\n}\n\nexport interface UpsertOperationInput {\n  partitionKey?: PartitionKey;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Upsert;\n  resourceBody: JSONObject;\n}\n\nexport interface ReadOperationInput {\n  partitionKey?: PartitionKey;\n  operationType: typeof BulkOperationType.Read;\n  id: string;\n}\n\nexport interface DeleteOperationInput {\n  partitionKey?: PartitionKey;\n  operationType: typeof BulkOperationType.Delete;\n  id: string;\n}\n\nexport interface ReplaceOperationInput {\n  partitionKey?: PartitionKey;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Replace;\n  resourceBody: JSONObject;\n  id: string;\n}\n\nexport interface PatchOperationInput {\n  partitionKey?: PartitionKey;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Patch;\n  resourceBody: PatchRequestBody;\n  id: string;\n}\n\nexport type OperationWithItem = OperationBase & {\n  resourceBody: JSONObject;\n};\n\nexport type CreateOperation = OperationWithItem & {\n  operationType: typeof BulkOperationType.Create;\n};\n\nexport type UpsertOperation = OperationWithItem & {\n  operationType: typeof BulkOperationType.Upsert;\n};\n\nexport type ReadOperation = OperationBase & {\n  operationType: typeof BulkOperationType.Read;\n  id: string;\n};\n\nexport type DeleteOperation = OperationBase & {\n  operationType: typeof BulkOperationType.Delete;\n  id: string;\n};\n\nexport type ReplaceOperation = OperationWithItem & {\n  operationType: typeof BulkOperationType.Replace;\n  id: string;\n};\n\nexport type BulkPatchOperation = OperationBase & {\n  operationType: typeof BulkOperationType.Patch;\n  id: string;\n};\n\nexport function hasResource(\n  operation: Operation,\n): operation is CreateOperation | UpsertOperation | ReplaceOperation {\n  return (\n    operation.operationType !== \"Patch\" &&\n    (operation as OperationWithItem).resourceBody !== undefined\n  );\n}\n/**\n * Maps OperationInput to Operation by\n * - generating Ids if needed.\n * - choosing partitionKey which can be used to choose which batch this\n * operation should be part of. The order is -\n *   1. If the operationInput itself has partitionKey field set it is used.\n *   2. Other wise for create/replace/upsert it is extracted from resource body.\n *   3. For read/delete/patch type operations undefined partitionKey is used.\n * - Here one nuance is that, the partitionKey field inside Operation needs to\n *  be serialized as a JSON string.\n * @param operationInput - OperationInput\n * @param definition - PartitionKeyDefinition\n * @param options - RequestOptions\n * @returns\n */\nexport function prepareOperations(\n  operationInput: OperationInput,\n  definition: PartitionKeyDefinition,\n  options: RequestOptions = {},\n): {\n  operation: Operation;\n  partitionKey: PrimitivePartitionKeyValue[];\n} {\n  populateIdsIfNeeded(operationInput, options);\n\n  let partitionKey: PrimitivePartitionKeyValue[];\n  if (Object.prototype.hasOwnProperty.call(operationInput, \"partitionKey\")) {\n    if (operationInput.partitionKey === undefined) {\n      partitionKey = definition.paths.map(() => NonePartitionKeyLiteral);\n    } else {\n      partitionKey = convertToInternalPartitionKey(operationInput.partitionKey);\n    }\n  } else {\n    switch (operationInput.operationType) {\n      case BulkOperationType.Create:\n      case BulkOperationType.Replace:\n      case BulkOperationType.Upsert:\n        partitionKey = assertNotUndefined(\n          extractPartitionKeys(operationInput.resourceBody, definition),\n          \"Unexpected undefined Partition Key Found.\",\n        );\n        break;\n      case BulkOperationType.Read:\n      case BulkOperationType.Delete:\n      case BulkOperationType.Patch:\n        partitionKey = definition.paths.map(() => NonePartitionKeyLiteral);\n    }\n  }\n  return {\n    operation: { ...operationInput, partitionKey: JSON.stringify(partitionKey) } as Operation,\n    partitionKey,\n  };\n}\n\n/**\n * For operations requiring Id genrate random uuids.\n * @param operationInput - OperationInput to be checked.\n * @param options - RequestOptions\n */\nfunction populateIdsIfNeeded(operationInput: OperationInput, options: RequestOptions) {\n  if (\n    operationInput.operationType === BulkOperationType.Create ||\n    operationInput.operationType === BulkOperationType.Upsert\n  ) {\n    if (\n      (operationInput.resourceBody.id === undefined || operationInput.resourceBody.id === \"\") &&\n      !options.disableAutomaticIdGeneration\n    ) {\n      operationInput.resourceBody.id = uuid();\n    }\n  }\n}\n\n/**\n * Splits a batch into array of batches based on cumulative size of its operations by making sure\n * cumulative size of an individual batch is not larger than {@link Constants.DefaultMaxBulkRequestBodySizeInBytes}.\n * If a single operation itself is larger than {@link Constants.DefaultMaxBulkRequestBodySizeInBytes}, that\n * operation would be moved into a batch containing only that operation.\n * @param originalBatch - A batch of operations needed to be checked.\n * @returns\n * @hidden\n */\nexport function splitBatchBasedOnBodySize(originalBatch: Batch): Batch[] {\n  if (originalBatch?.operations === undefined || originalBatch.operations.length < 1) return [];\n  let currentBatchSize = calculateObjectSizeInBytes(originalBatch.operations[0]);\n  let currentBatch: Batch = {\n    ...originalBatch,\n    operations: [originalBatch.operations[0]],\n    indexes: [originalBatch.indexes[0]],\n  };\n  const processedBatches: Batch[] = [];\n  processedBatches.push(currentBatch);\n\n  for (let index = 1; index < originalBatch.operations.length; index++) {\n    const operation = originalBatch.operations[index];\n    const currentOpSize = calculateObjectSizeInBytes(operation);\n    if (currentBatchSize + currentOpSize > Constants.DefaultMaxBulkRequestBodySizeInBytes) {\n      currentBatch = {\n        ...originalBatch,\n        operations: [],\n        indexes: [],\n      };\n      processedBatches.push(currentBatch);\n      currentBatchSize = 0;\n    }\n    currentBatch.operations.push(operation);\n    currentBatch.indexes.push(originalBatch.indexes[index]);\n    currentBatchSize += currentOpSize;\n  }\n  return processedBatches;\n}\n\n/**\n * Calculates size of an JSON object in bytes with utf-8 encoding.\n * @hidden\n */\nexport function calculateObjectSizeInBytes(obj: unknown): number {\n  return new TextEncoder().encode(bodyFromData(obj as any)).length;\n}\n\nexport function decorateBatchOperation(\n  operation: OperationInput,\n  options: RequestOptions = {},\n): Operation {\n  if (\n    operation.operationType === BulkOperationType.Create ||\n    operation.operationType === BulkOperationType.Upsert\n  ) {\n    if (\n      (operation.resourceBody.id === undefined || operation.resourceBody.id === \"\") &&\n      !options.disableAutomaticIdGeneration\n    ) {\n      operation.resourceBody.id = uuid();\n    }\n  }\n  return operation as Operation;\n}\n"]}